/*Seccion codigo Imports Package */
package com.sistema.musicserver.analizadores.pista;

import java_cup.runtime.*;
import java.util.ArrayList;
import com.sistema.musicserver.pista.Pista;
import com.sistema.musicserver.tablaSimbol.TablaSimbol;
import com.sistema.musicserver.instrucciones.declaracionAsignacion.*;
import com.sistema.musicserver.errors.ErrorSemantico;
import com.sistema.musicserver.tablaSimbol.Variable;
import com.sistema.musicserver.instrucciones.funciones.*;
import com.sistema.musicserver.instrucciones.Instruccions;
import com.sistema.musicserver.instrucciones.bifurcaciones.*;



 /* Codigo java del parser*/
 parser code {:   

        private TipoDato tipo;
        private Pista pista;
        private boolean asigna= false;
        private Operation instrOp;
        private ArrayList<ErrorSemantico> errorsSemanticos = new ArrayList<ErrorSemantico>();
        private ArrayList<Variable> parametros = new ArrayList<Variable>();


 /* Connect this parser to a scanner!*/
	public parser(LexerPista analizadorLexico) {
		super(analizadorLexico);
	}

       
        public ArrayList<ErrorSemantico> getErrorsSemanticos() {
                return errorsSemanticos;
        }

        public void setErrorsSemanticos(ArrayList<ErrorSemantico> errorsSemanticos) {
                this.errorsSemanticos = errorsSemanticos;
        }



        @Override
        public void syntax_error(Symbol tok) {
	    try{
	        Token token = (Token) tok.value;
	        report_error("Error Sintactico con el  Token:"+ token.getLexeme()+" este no pertenece a la estructura - linea: "+token.getLine()+" - columna: "+token.getColumn() + "\n",null);
	    }catch(Exception e){
                e.printStackTrace();
	    }	
	}

/**
    public void unrecovered_syntax_error(Symbol cur_token) {
        if (cur_token.sym == sym.EOF) {
             System.out.println("SE ESPERABA UNA LLAVE FINAL");  
        }else{
             Token token = (Token) cur_token.value;
	     report_error("Error Sintactico con el  Token:"+ token.getLexeme()+" este no pertenece a la estructura - linea: "+token.getLine()+" - columna: "+token.getColumn() + "\n",null);
        }
    }
    
*/
:};


/*seccion de Terminales*/ 
terminal Token PISTA, ID, EXTIENDE, LLAVEA, LLAVEC, COMA ,PARENTESISA, PARENTESISC, NUM_ENTERO, DECIMAL, CONT_CARACTER, CONT_CADENA,  FALSO, VERDADERO, MAS, MENOS, POR, DIVISION, MODULO, POTENCIA, MAYORQ, MENORQ, MAYOROI, MENOROI, NOTEQUALS, EQUALS, ENTERO, DOBLE, BOOLEAN, CADENA, CARACTER, IGUAL, PUNTOCOMA, VAR, KEEP, ISNULO, MIENTRAS;
terminal Token OR, XOR, NOR, AND, NAND, NOT, SUMA_IMPLICITA, INCREMENT, DECREMENT, SI, SINO, DOPUNTO, SWITCH, SALIR, CASO, DEFAULT,PARA, HACER, RETORNA, ISNXORULO, CORCHETA, CORCHETC,ARREGLO, ESPERAR, MENSAJE, ORDENAR, LONGITUD, CONTINUAR, PRINCIPAL, SUMARIZAR, REPRODUCIR;
 

/*seccion de No Terminales*/
non terminal inicio, def_pista, comodin_pista, comodin_extiende, items_extiende, sentencias_global, sentencia_global, def_variable, variables, tipo, items_coma, items, asignacion, operation, terminal_casos, asignacion_var, comodin_fun, parametros, comodin_param, cierre_fun, def_funciones, sentencia, variables_fun, asignacion_var_fun, op_incremt_decremet_fun;
non terminal items_coma_fun, items_fun, sentencias, terminales_increment_fun, llamada_metod, parametros_llamada, def_else_if, def_else, def_if, def_if_complete, condition, sentencias_bifuraciones, terminales_switch, caso_sw, cases, def_switch, op_incremt_decremet_for, var_iterador, condition_for, def_for, def_while, def_do_while, tipo_fun, asignacion_iterador;

/* agregado de precedencias */
precedence left OR, XOR, NOR;
precedence left AND, NAND;
precedence left NOT;
precedence left EQUALS, NOTEQUALS, MAYORQ, MAYOROI, MENORQ, MENOROI;
precedence left ISNULO;
precedence left MENOS, MAS;
precedence left POR, DIVISION, MODULO;
precedence left POTENCIA;

/* seccion de Gramatica */
start with  inicio;

inicio ::= def_pista
        | 
        ;

/*Gramatica para definicion de la pista*/
def_pista ::=  comodin_pista LLAVEA sentencias_global LLAVEC                    {:pista.referenciarTablasPadres(); pista.tostringDAts();:}          
        ;


comodin_pista ::= PISTA:pist ID                                 {:pista = new Pista(pist.getLexeme(), new TablaSimbol(errorsSemanticos), errorsSemanticos);:}      
                | PISTA ID comodin_extiende
                ;

comodin_extiende ::= EXTIENDE ID items_extiende
                    ;

items_extiende ::= COMA ID items_extiende
                |
                ;


/*Gramatica para sentencias, globales o que directamente estan en la clase */
 sentencias_global ::= sentencia_global sentencias_global
        |
        ;

/*Gramatica para sentencia global  */
 sentencia_global ::=  def_variable
                    | asignacion_var
                    | def_funciones:fun                                             {:pista.getInstrucciones().add((Funcion) fun);:}          
                    ;


/*Gramatica para definir una variable o/y asignarla, de forma global*/
 def_variable ::=  variables                                                    {:pista.carpturarVariablesGlobales(tipo,asigna, instrOp); asigna= false;:}                                                 
        | KEEP variables                                                        {:pista.carpturarVariablesGlobales(tipo,asigna, instrOp); asigna= false;:}                                             
        ;

/*Gramatica para variables, asiganion o definicion*/
 variables ::= VAR tipo items_coma                                                                
        ; 


/*Gramatica para  items separadas por comas*/
 items_coma ::= ID:id items                                         {:pista.getTableSimbolGoblal().capturarIds((Token) id);:}                                                                                                                                                
            ;

/*Gramatica para asiganar o tener recursividad*/
 items ::= IGUAL asignacion PUNTOCOMA                                                                       
        | COMA items_coma                                       
        | PUNTOCOMA                                                                                                  
        ; 


/*Gramatica para tipo */
tipo ::= ENTERO                                         {:tipo=TipoDato.ENTERO;:}                                                                              
        | DOBLE                                         {:tipo=TipoDato.DECIMAL;:}                                                    
        | BOOLEAN                                       {:tipo=TipoDato.BOOLEAN;:}                                                     
        | CADENA                                        {:tipo=TipoDato.CADENA;:}                                                     
        | CARACTER                                      {:tipo=TipoDato.CHAR;:}                                                       
        ; 

/*gramatica para asiganar variables ya declaradas*/
asignacion_var ::= ID:id IGUAL asignacion:opera PUNTOCOMA                {:pista.capturarAsignacion(id, (Operation) opera);:}
                ;

/*Gramatica para asignacion */
 asignacion ::= operation:rootOp                                        {:RESULT = new Operation((NodoOperation) rootOp); instrOp =new Operation((NodoOperation) rootOp); asigna= true;:}                                               
            ;


/*Gramatica de operacion aritmetica*/
operation ::= operation:opLeft MAS operation:opRight                                           {:RESULT = new NodoOperation(TipoOperacion.SUMA, (NodoOperation) opLeft, (NodoOperation) opRight);:}   		 
	| operation:opLeft MENOS operation:opRight                                             {:RESULT = new NodoOperation(TipoOperacion.RESTA, (NodoOperation) opLeft, (NodoOperation) opRight);:}			 
	| operation:opLeft POR operation:opRight                                               {:RESULT = new NodoOperation(TipoOperacion.MULTIPLICACION, (NodoOperation) opLeft,(NodoOperation) opRight);:}				 
	| operation:opLeft DIVISION operation:opRight                                          {:RESULT = new NodoOperation(TipoOperacion.DIVISION, (NodoOperation) opLeft, (NodoOperation) opRight);:}			 
	| operation:opLeft MODULO operation:opRight                                            {:RESULT = new NodoOperation(TipoOperacion.MODULO, (NodoOperation) opLeft, (NodoOperation) opRight);:}			 
	| operation:opLeft POTENCIA operation:opRight                                          {:RESULT = new NodoOperation(TipoOperacion.POTENCIA, (NodoOperation) opLeft, (NodoOperation) opRight);:}
        | operation MAYORQ operation
        | operation MENORQ operation
        | operation MAYOROI operation
        | operation MENOROI operation
        | operation NOTEQUALS operation
        | operation EQUALS operation
        | ISNULO operation %prec  ISNULO
        | NOT operation	%prec NOT		 
        | operation OR operation
        | operation AND operation
        | operation NAND operation
        | operation NOR operation
        | operation XOR operation
        | terminal_casos:nodoOp                                                                 {:RESULT = nodoOp;:}    													 
	| PARENTESISA operation:nodoOp PARENTESISC                                              {:RESULT = nodoOp;:} 					
	;

/*Gramatica para rerminal de los cosso */
 terminal_casos ::= ID:val                                              {:RESULT = new NodoOperation(new Dato(false,(Token) val,TipoDato.ENTERO,val.getLexeme()));:}                                                 
                | llamada_metod
                | NUM_ENTERO:val                                        {:RESULT = new NodoOperation(new Dato(true,(Token) val,TipoDato.ENTERO));:}            
                | DECIMAL:val                                           {:RESULT = new NodoOperation(new Dato(true,(Token) val,TipoDato.DECIMAL));:}               
                | CONT_CARACTER:val                                     {:RESULT = new NodoOperation(new Dato(true,(Token) val,TipoDato.CHAR));:}         
                | CONT_CADENA:val                                       {:RESULT = new NodoOperation(new Dato(true,(Token) val,TipoDato.CADENA));:}           
                | FALSO:val                                             {:RESULT = new NodoOperation(new Dato(true,(Token) val,TipoDato.BOOLEAN));:} 
                | VERDADERO:val                                         {:RESULT = new NodoOperation(new Dato(true,(Token) val,TipoDato.BOOLEAN));:}             
                ;
 


/*Gramatica para funciones/procedimientos/metodos*/
def_funciones  ::= comodin_fun:fun LLAVEA sentencias:sent LLAVEC                    {:Funcion funs = (Funcion) fun; funs.setInstruccions((ArrayList<Instruccions>) sent); parametros.clear(); RESULT = funs; :}
                ;

comodin_fun ::= KEEP tipo_fun:tip ID:id PARENTESISA cierre_fun                                  {:RESULT = new Funcion(parametros, new TablaSimbol(errorsSemanticos, true),id.getLexeme(),(Token) id, (TipoDato)tip); :}                                 
                | KEEP ID:id PARENTESISA cierre_fun                                             {:RESULT = new Funcion(parametros, new TablaSimbol(errorsSemanticos, true),id.getLexeme(),(Token) id); :}                                       
                | tipo_fun:tip ID:id PARENTESISA cierre_fun                                     {:RESULT = new Funcion(parametros, new TablaSimbol(errorsSemanticos, true),id.getLexeme(),(Token) id, (TipoDato)tip); :}                                      
                | ID:id PARENTESISA cierre_fun                                                {:RESULT = new Funcion(parametros, new TablaSimbol(errorsSemanticos, true),id.getLexeme(),(Token) id); :}
                ;

cierre_fun ::= parametros PARENTESISC
                | PARENTESISC
                ;

/*Gramatica para tipo de la funcion */
tipo_fun ::= ENTERO                                     {:RESULT =TipoDato.ENTERO;:}                                                                              
        | DOBLE                                         {:RESULT =TipoDato.DECIMAL;:}                                                    
        | BOOLEAN                                       {:RESULT =TipoDato.BOOLEAN;:}                                                     
        | CADENA                                        {:RESULT =TipoDato.CADENA;:}                                                     
        | CARACTER                                      {:RESULT =TipoDato.CHAR;:}                                                       
        ; 



/*gramatica para parematros*/
parametros ::= comodin_param
            | comodin_param COMA parametros
            ;
            
comodin_param ::= tipo ID:id                                                            {:parametros.add(new Variable((Token)id, tipo, "",false));:}          
                ;


/*Gramatica para sentencias, pueden venir dentro de una funcion o metodo */
 sentencias ::= sentencia:sent sentencias:array                                         {: ArrayList<Instruccions> arr= (ArrayList<Instruccions>)array; arr.add(0,(Instruccions)sent); RESULT = arr;:}                                          
        |                                                                               {:RESULT = new ArrayList<Instruccions>();:}
        ;

/*Gramatica para sentencia, esta puede venir dentro de las funciones o metodos  */
 sentencia ::=  variables_fun:array                                                     {:RESULT = new DeclaracionVar((ArrayList<Variable>)array,asigna,(Operation) instrOp) ;:}
        | asignacion_var_fun:asig                                                       {:RESULT = asig;:}
        | op_incremt_decremet_fun:decrInc PUNTOCOMA                                     {:RESULT = decrInc;:}
        | llamada_metod PUNTOCOMA
        | sentencias_bifuraciones:sentbifu                                              {:RESULT = sentbifu;:}
        | RETORNA:tok operation:op PUNTOCOMA                                            {:RESULT = new SentenciaRetorna((Operation) op, (Token) tok, errorsSemanticos);:}
        ;

/*gramatica para asiganar variables ya declaradas esto dentro de las funciones o metodos*/
asignacion_var_fun ::= ID:id IGUAL asignacion:op PUNTOCOMA                              {:RESULT = new Asignacion((Operation)op,(Token)id,true);:}
                    ;

/*Gramatica para definir una variable o/y asignarla, de forma global dentro de funciones*/
 variables_fun ::= VAR tipo items_coma_fun: array                                      {:RESULT  = array;:}
        ; 


/*Gramatica para  items separadas por comas*/
 items_coma_fun ::= ID:id items_fun:array                                        {:ArrayList<Variable> arryTmp = (ArrayList<Variable>) array; arryTmp.add( new Variable((Token)id,tipo, "", asigna)); RESULT = arryTmp;:}                                                          
            ;

/*Gramatica para asiganar o tener recursividad*/
 items_fun ::= IGUAL asignacion PUNTOCOMA                               {:RESULT = new ArrayList<Variable>();:}        
        | COMA items_coma_fun:array                                     {:RESULT = array;:}
        | PUNTOCOMA                                                     {:RESULT = new ArrayList<Variable>();:} 
        ; 

/*gramatica para operaciones incremet y decremet*/
op_incremt_decremet_fun ::= ID:id SUMA_IMPLICITA  terminales_increment_fun:nodRight                             {:NodoOperation nodLeft = new NodoOperation(new Dato(false, (Token) id, TipoDato.ENTERO, id.getLexeme())); NodoOperation root = new NodoOperation(TipoOperacion.SUMA, nodLeft, (NodoOperation) nodRight ); RESULT = new Asignacion(new Operation(root), (Token) id, true);:}
                    | ID:id INCREMENT                                                                           {:NodoOperation nodLeft = new NodoOperation(new Dato(false, (Token) id, TipoDato.ENTERO, id.getLexeme())); NodoOperation nodRight = new NodoOperation(new Dato(true, 1, TipoDato.ENTERO)); NodoOperation root = new NodoOperation(TipoOperacion.SUMA, nodLeft, nodRight ); RESULT = new Asignacion(new Operation(root), (Token) id, true);:}
                    | ID:id DECREMENT                                                                           {:NodoOperation nodLeft = new NodoOperation(new Dato(false, (Token) id, TipoDato.ENTERO, id.getLexeme())); NodoOperation nodRight = new NodoOperation(new Dato(true, 1, TipoDato.ENTERO)); NodoOperation root = new NodoOperation(TipoOperacion.RESTA, nodLeft, nodRight); RESULT = new Asignacion(new Operation(root), (Token) id, true);:}
                    ;

terminales_increment_fun ::= ID:val         {:RESULT = new NodoOperation(new Dato(false,(Token) val,TipoDato.ENTERO,val.getLexeme()));:}
                        | NUM_ENTERO:val    {:RESULT = new NodoOperation(new Dato(true,(Token) val,TipoDato.ENTERO));:}
                        | DECIMAL:val       {:RESULT = new NodoOperation(new Dato(true,(Token) val,TipoDato.DECIMAL));:}
                        ;


/*gramatica para llamada de metodos o funciones*/
llamada_metod ::= ID PARENTESISA  PARENTESISC 
                | ID PARENTESISA parametros_llamada PARENTESISC 
                ;


/*gramatica para los parametros de las llamadas*/
parametros_llamada ::= terminal_casos COMA parametros_llamada
            | terminal_casos
            ;

/*sentencias de control como if, else, for, while etc*/
sentencias_bifuraciones ::= def_if_complete:sent     {:RESULT = sent;:}
                        | def_switch:sent            {:RESULT = sent;:}
                        | def_for:sent               {:RESULT = sent;:}
                        | def_while:sent             {:RESULT = sent;:}
                        | def_do_while:sent          {:RESULT = sent;:} 
                        ;

                        
/*Gramatica para condiciones que evaluaran la bifurcaciones */
 condition ::= operation:rootOp                                                                 {:RESULT = new Operation((NodoOperation) rootOp);:}                                                  
            ;

/*definicion de un if, if else, if elseif else*/
def_if_complete ::= def_if:senIf                                                                {:RESULT = senIf;:} 
                | def_if:senIf def_else:senElse                                                 {:SentenciaIF nIf = (SentenciaIF) senIf; nIf.setSentenciaElse((SentenciaElse) senElse); RESULT = nIf;:}
                | def_if:senIf  def_else_if:senIfs                                              {:SentenciaIF nIf = (SentenciaIF) senIf; nIf.setSentenciaElseIf((SentenciaIF) senIfs); RESULT = nIf;:}
                ;

/*Gramatica para if  */
def_if ::= SI PARENTESISA condition:op  PARENTESISC LLAVEA sentencias:sent LLAVEC               {:RESULT = new SentenciaIF((ArrayList<Instruccions>) sent,(Operation)op, new TablaSimbol(errorsSemanticos) );:}
        ;

/*Gramatica para ELSE  */
def_else ::= SINO LLAVEA sentencias:sent LLAVEC                                                 {:RESULT = new SentenciaElse((ArrayList<Instruccions>) sent, new TablaSimbol(errorsSemanticos) );:}
                ;

/*Gramatica para ELSE_if  */
def_else_if ::= SINO def_if:senIf                                                               {:RESULT = senIf;:}                                                                               
                | SINO def_if:senIf def_else:senElse                                            {:SentenciaIF nIf = (SentenciaIF) senIf; nIf.setSentenciaElse((SentenciaElse) senElse); RESULT = nIf;:}                                                                    
                | SINO def_if:senIf  def_else_if:senIfs                                         {:SentenciaIF nIf = (SentenciaIF) senIf; nIf.setSentenciaElseIf((SentenciaIF) senIfs); RESULT = nIf;:}                                                                                     
                ;


/*Gramatica para switch  */
def_switch ::= SWITCH PARENTESISA ID:id PARENTESISC LLAVEA cases:arryC LLAVEC                            {:RESULT = new SentenciaSwitch((ArrayList<CasoSwitch> ) arryC, new Variable((Token) id, TipoDato.ENTERO, "",false),  new TablaSimbol(errorsSemanticos));:}
        ;

/*Gramatica para casos dentro del switch  */
 cases ::= caso_sw:cass SALIR cases:arryC                                                               {:ArrayList<CasoSwitch> arr = (ArrayList<CasoSwitch>)arryC; arr.add(0,(CasoSwitch)cass); RESULT = arr;:}
        |                                                                                               {:RESULT = new ArrayList<CasoSwitch>(); :}
        ;

/*Gramatica para casos */
 caso_sw ::= CASO terminales_switch:dat DOPUNTO sentencias:inst                                 {:RESULT = new CasoSwitch((ArrayList<Instruccions>)inst,(Dato) dat);:}         
            | DEFAULT DOPUNTO sentencias:inst                                                   {:RESULT = new CasoSwitch((ArrayList<Instruccions>)inst,null);:}             
            ;



terminales_switch ::= ID:val                                    {:RESULT = new Dato(false, (Token) val, TipoDato.ENTERO, val.getLexeme());;:}        
                | NUM_ENTERO:val                                {:RESULT = new Dato(true, (Token) val, TipoDato.ENTERO);:}                                                           
                | DECIMAL:val                                   {:RESULT = new Dato(true, (Token) val, TipoDato.DECIMAL);:}                                                 
                | CONT_CARACTER:val                             {:RESULT = new Dato(true, (Token) val, TipoDato.CADENA);:}                                                     
                | CONT_CADENA:val                               {:RESULT = new Dato(true, (Token) val, TipoDato.CHAR);:}                                                         
                | FALSO:val                                     {:RESULT = new Dato(true, (Token) val, TipoDato.BOOLEAN);:}                                                     
                | VERDADERO:val                                 {:RESULT = new Dato(true, (Token) val, TipoDato.BOOLEAN);:}                                                     
                ;


/*Gramatica para FOR  */
 def_for ::= PARA PARENTESISA condition_for:fors PARENTESISC  LLAVEA sentencias:instr LLAVEC                          {:SentenciaFor senFor = (SentenciaFor)fors; senFor.setInstruccions((ArrayList<Instruccions>) instr); RESULT = senFor;:}
        ;

/*Gramatica para logica de condidicon del for*/
 condition_for ::= var_iterador:inst PUNTOCOMA condition:condi PUNTOCOMA op_incremt_decremet_for:increm                  {:RESULT = new SentenciaFor((Instruccions)inst,  new TablaSimbol(errorsSemanticos), (Asignacion)increm, (Operation) condi);:}
            ;


var_iterador ::= ENTERO ID:id  asignacion_iterador:op                 {: ArrayList<Variable> variables= new ArrayList<Variable>(); variables.add(new Variable((Token ) id, TipoDato.ENTERO, "", true)); RESULT = new DeclaracionVar(variables, true, (Operation)op);:}
            | DOBLE ID:id  asignacion_iterador:op                     {: ArrayList<Variable> variables= new ArrayList<Variable>(); variables.add(new Variable((Token ) id, TipoDato.DECIMAL, "", true)); RESULT = new DeclaracionVar(variables, true, (Operation)op);:}
            | ID:id  asignacion_iterador:op                           {:RESULT = new Asignacion((Operation) op, (Token) id, true);:}
            ;

asignacion_iterador ::= IGUAL ID:val                        {:RESULT = new Operation(new Dato(false,(Token) val,TipoDato.ENTERO,val.getLexeme()));:}
                |  IGUAL NUM_ENTERO:val                     {:RESULT = new Operation(new Dato(true,(Token) val,TipoDato.ENTERO));:}          
                | IGUAL DECIMAL:val                         {:RESULT = new Operation(new Dato(true,(Token) val,TipoDato.DECIMAL));:}  
                ;


op_incremt_decremet_for ::= ID:id INCREMENT                        {:NodoOperation nodLeft = new NodoOperation(new Dato(false, (Token) id, TipoDato.ENTERO, id.getLexeme())); NodoOperation nodRight = new NodoOperation(new Dato(true, 1, TipoDato.ENTERO)); NodoOperation root = new NodoOperation(TipoOperacion.SUMA, nodLeft, nodRight ); RESULT = new Asignacion(new Operation(root), (Token) id, true);:}
                    | ID:id DECREMENT                              {:NodoOperation nodLeft = new NodoOperation(new Dato(false, (Token) id, TipoDato.ENTERO, id.getLexeme())); NodoOperation nodRight = new NodoOperation(new Dato(true, 1, TipoDato.ENTERO)); NodoOperation root = new NodoOperation(TipoOperacion.RESTA, nodLeft, nodRight); RESULT = new Asignacion(new Operation(root), (Token) id, true);:}
                    ;


/*Gramatica para while  */
def_while ::= MIENTRAS PARENTESISA condition:cond PARENTESISC  LLAVEA sentencias:sent LLAVEC                                            {:RESULT = new SentenciaWhile((ArrayList<Instruccions> )sent, (Operation) cond, new TablaSimbol(errorsSemanticos));:}               
        ;


/*Gramatica para do_while  */
def_do_while ::= HACER LLAVEA sentencias:sent LLAVEC MIENTRAS PARENTESISA condition:cond PARENTESISC PUNTOCOMA                            {:RESULT = new SentenciaDoWhile((ArrayList<Instruccions> )sent, (Operation) cond, new TablaSimbol(errorsSemanticos));:}          
        ;



        